//@version=6
strategy('structure/session/signals Strategy', overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500,
     initial_capital = 25000, commission_type = strategy.commission.percent, commission_value = 0.05, slippage = 2,
     explicit_plot_zorder=true)
//---------------------------------------------------------------------------------------------------------------------}
//CONSTANTS & STRINGS & INPUTS
//---------------------------------------------------------------------------------------------------------------------{
BULLISH_LEG                     = 1
BEARISH_LEG                     = 0

BULLISH                         = +1
BEARISH                         = -1

GREEN                           = #4a7c59
RED                             = #8b5a5a
BLUE                            = #2157f3
GRAY                            = #878b94
MONO_BULLISH                    = #b2b5be
MONO_BEARISH                    = #5d606b

HISTORICAL                      = 'Historical'
PRESENT                         = 'Present'

COLORED                         = 'Colored'
MONOCHROME                      = 'Monochrome'

ALL                             = 'All'
BOS                             = 'BOS'
CHOCH                           = 'CHoCH'

TINY                            = size.tiny
SMALL                           = size.small
NORMAL                          = size.normal

ATR                             = 'Atr'
RANGE                           = 'Cumulative Mean Range'

CLOSE                           = 'Close'
HIGHLOW                         = 'High/Low'

SOLID                           = '⎯⎯⎯'
DASHED                          = '----'
DOTTED                          = '····'

SMART_GROUP                     = 'Smart Money Concepts'
SIGNAL_GROUP                    = 'Signal Generation'
TREND_GROUP                     = 'EMA Trend Signal'
INTERNAL_GROUP                  = 'Real Time Internal Structure'
SWING_GROUP                     = 'Real Time Swing Structure'
BLOCKS_GROUP                    = 'Order Blocks'
EQUAL_GROUP                     = 'EQH/EQL'
GAPS_GROUP                      = 'Fair Value Gaps'
LEVELS_GROUP                    = 'Highs & Lows MTF'
ZONES_GROUP                     = 'Premium & Discount Zones'
SESSION_GROUP                   = 'Session Management'
LIQUIDITY_GROUP                 = 'Liquidity & Sweeps'

ANALYSIS                        = 'Analysis'
SIGNAL                          = 'Signal'
OPEN                            = 'Open'
WIN                             = 'Win'
LOSS                            = 'Loss'

modeTooltip                     = 'Allows to display historical Structure or only the recent ones'
styleTooltip                    = 'Indicator color theme'
showTrendTooltip                = 'Display additional candles with a color reflecting the current trend detected by structure'
showInternalsTooltip            = 'Display internal market structure'
internalFilterConfluenceTooltip = 'Filter non significant internal structure breakouts'
showStructureTooltip            = 'Display swing market Structure'
showSwingsTooltip               = 'Display swing point as labels on the chart'
showHighLowSwingsTooltip        = 'Highlight most recent strong and weak high/low points on the chart'
showInternalOrderBlocksTooltip  = 'Display internal order blocks on the chart\n\nNumber of internal order blocks to display on the chart'
showSwingOrderBlocksTooltip     = 'Display swing order blocks on the chart\n\nNumber of internal swing blocks to display on the chart'
orderBlockFilterTooltip         = 'Method used to filter out volatile order blocks \n\nIt is recommended to use the cumulative mean range method when a low amount of data is available'
orderBlockMitigationTooltip     = 'Select what values to use for order block mitigation'
showEqualHighsLowsTooltip       = 'Display equal highs and equal lows on the chart'
equalHighsLowsLengthTooltip     = 'Number of bars used to confirm equal highs and equal lows'
equalHighsLowsThresholdTooltip  = 'Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results'
showFairValueGapsTooltip        = 'Display fair values gaps on the chart'
fairValueGapsThresholdTooltip   = 'Filter out non significant fair value gaps'
fairValueGapsTimeframeTooltip   = 'Fair value gaps timeframe'
fairValueGapsExtendTooltip      = 'Determine how many bars to extend the Fair Value Gap boxes on chart'
showPremiumDiscountZonesTooltip = 'Display premium, discount, and equilibrium zones on chart'

// Signal Generation Inputs
enableBuySignals  = input.bool(true, 'Enable Buy Signals', group=SIGNAL_GROUP, tooltip='Enable generation of buy signals based on defined logic.', display=display.none)
enableSellSignals = input.bool(true, 'Enable Sell Signals', group=SIGNAL_GROUP, tooltip='Enable generation of sell signals based on defined logic.', display=display.none)

// Session Management Inputs
tz = input.string("Europe/Bratislava", "Timezone (IANA)", group = SESSION_GROUP,
     tooltip = "Recommended: use IANA timezone (e.g., Europe/Bratislava).\nIf you want fixed UTC+2, use Etc/GMT-2.")

// Morning session
morning_start_h = input.int(6, "Morning Start Hour", minval=0, maxval=23, group=SESSION_GROUP)
morning_start_m = input.int(0, "Morning Start Minute", minval=0, maxval=59, group=SESSION_GROUP)
morning_end_h   = input.int(10, "Morning End Hour", minval=0, maxval=23, group=SESSION_GROUP)
morning_end_m   = input.int(0, "Morning End Minute", minval=0, maxval=59, group=SESSION_GROUP)
morning_color   = input.color(color.new(#ffb74d, 80), "Morning Color", group=SESSION_GROUP)
morning_name    = input.string("Morning", "Morning Label", group=SESSION_GROUP)

// Afternoon session
afternoon_start_h = input.int(13, "Afternoon Start Hour", minval=0, maxval=23, group=SESSION_GROUP)
afternoon_start_m = input.int(0, "Afternoon Start Minute", minval=0, maxval=59, group=SESSION_GROUP)
afternoon_end_h   = input.int(16, "Afternoon End Hour", minval=0, maxval=23, group=SESSION_GROUP)
afternoon_end_m   = input.int(0, "Afternoon End Minute", minval=0, maxval=59, group=SESSION_GROUP)
afternoon_color   = input.color(color.new(#81c784, 80), "Afternoon Color", group=SESSION_GROUP)
afternoon_name    = input.string("Afternoon", "Afternoon Label", group=SESSION_GROUP)

// Display options
show_open_close    = input.bool(true, "Show Open/Close Lines", group=SESSION_GROUP)

// EMA Trend Inputs
showEmaInput = input.bool(true, 'Show EMA Trend', group=TREND_GROUP, display=display.none)
emaUseCurrentRes = input.bool(true, title='Use Current Chart Resolution?', group=TREND_GROUP, display=display.none)
emaResCustom = input.timeframe('15', title='Custom Timeframe', group=TREND_GROUP, display=display.none)
emaLen = input.int(20, title='EMA Length', minval=1, group=TREND_GROUP, display=display.none)
emaType = input.int(2, minval=1, maxval=8, title='MA Type: 1=SMA, 2=EMA, 3=WMA, 4=Hull, 5=VWMA, 6=RMA, 7=TEMA, 8=T3', group=TREND_GROUP, display=display.none)
emaFactorT3 = input.float(0.7, title='T3 Factor', minval=0, maxval=1, step=0.1, group=TREND_GROUP, display=display.none)
emaColorDirection = input.bool(true, title='Color Based On Direction?', group=TREND_GROUP, display=display.none)
emaLineWidth = input.int(4, title='Line Width', minval=1, maxval=5, group=TREND_GROUP, display=display.none)

// Higher Timeframe EMA Inputs
showEmaHtfInput = input.bool(true, 'Show Higher TF EMA Trend', group=TREND_GROUP, display=display.none)
emaHtfResCustom = input.timeframe('240', title='Higher TF Custom Timeframe', group=TREND_GROUP, display=display.none) // 4 hours
emaHtfLen = input.int(20, title='Higher TF EMA Length', minval=1, group=TREND_GROUP, display=display.none)
emaHtfType = input.int(2, minval=1, maxval=8, title='Higher TF MA Type: 1=SMA, 2=EMA, 3=WMA, 4=Hull, 5=VWMA, 6=RMA, 7=TEMA, 8=T3', group=TREND_GROUP, display=display.none)
emaHtfFactorT3 = input.float(0.7, title='Higher TF T3 Factor', minval=0, maxval=1, step=0.1, group=TREND_GROUP, display=display.none)
emaHtfColorDirection = input.bool(true, title='Higher TF Color Based On Direction?', group=TREND_GROUP, display=display.none)
emaHtfLineWidth = input.int(2, title='Higher TF Line Width', minval=1, maxval=5, group=TREND_GROUP, display=display.none)

// Liquidity & Sweeps Inputs
showLiquiditySweepsInput = input.bool(true, 'Show Liquidity Sweeps', group=LIQUIDITY_GROUP, display=display.none)
sweepThresholdInput = input.float(0.5, 'Sweep Threshold (ATR Multiple)', minval=0, group=LIQUIDITY_GROUP, display=display.none)
ltfTimeframeInput = input.timeframe('3', 'LTF for OB Refinement', group=LIQUIDITY_GROUP, display=display.none)
htfTimeframeInput = input.timeframe('240', 'HTF for Pivots/Liquidity', group=LIQUIDITY_GROUP, display=display.none)
showSweepLabelsInput = input.bool(true, 'Show Sweep Labels', group=LIQUIDITY_GROUP, display=display.none)
useLtfRefinementInput = input.bool(true, 'Use LTF OB Refinement', group=LIQUIDITY_GROUP, display=display.none)

modeInput                       = input.string( HISTORICAL, 'Mode',                     group = SMART_GROUP,    tooltip = modeTooltip, options = [HISTORICAL, PRESENT], display=display.none)
styleInput                      = input.string( COLORED,    'Style',                    group = SMART_GROUP,    tooltip = styleTooltip,options = [COLORED, MONOCHROME], display=display.none)
showTrendInput                  = input(        false,      'Color Candles',            group = SMART_GROUP,    tooltip = showTrendTooltip, display=display.none)

showInternalsInput              = input(        true,       'Show Internal Structure',  group = INTERNAL_GROUP, tooltip = showInternalsTooltip, display=display.none)
showInternalBullInput           = input.string( ALL,        'Bullish Structure',        group = INTERNAL_GROUP, inline = 'ibull', options = [ALL,BOS,CHOCH], display=display.none)
internalBullColorInput          = input(        GREEN,      '',                         group = INTERNAL_GROUP, inline = 'ibull', display=display.none)
showInternalBearInput           = input.string( ALL,        'Bearish Structure' ,       group = INTERNAL_GROUP, inline = 'ibear', options = [ALL,BOS,CHOCH], display=display.none)
internalBearColorInput          = input(        RED,        '',                         group = INTERNAL_GROUP, inline = 'ibear', display=display.none)
internalFilterConfluenceInput   = input(        false,      'Confluence Filter',        group = INTERNAL_GROUP, tooltip = internalFilterConfluenceTooltip, display=display.none)
internalStructureSize           = input.string( TINY,       'Internal Label Size',      group = INTERNAL_GROUP, options = [TINY,SMALL,NORMAL], display=display.none)

showStructureInput              = input(        true,       'Show Swing Structure',     group = SWING_GROUP,    tooltip = showStructureTooltip, display=display.none)
showSwingBullInput              = input.string( ALL,        'Bullish Structure',        group = SWING_GROUP,    inline = 'bull',    options = [ALL,BOS,CHOCH], display=display.none)
swingBullColorInput             = input(        GREEN,      '',                         group = SWING_GROUP,    inline = 'bull', display=display.none)
showSwingBearInput              = input.string( ALL,        'Bearish Structure',        group = SWING_GROUP,    inline = 'bear',    options = [ALL,BOS,CHOCH], display=display.none)
swingBearColorInput             = input(        RED,        '',                         group = SWING_GROUP,    inline = 'bear', display=display.none)
swingStructureSize              = input.string( SMALL,      'Swing Label Size',         group = SWING_GROUP,    options = [TINY,SMALL,NORMAL], display=display.none)
showSwingsInput                 = input(        false,      'Show Swings Points',       group = SWING_GROUP,    tooltip = showSwingsTooltip,inline = 'swings', display=display.none)
swingsLengthInput               = input.int(    50,         '',                         group = SWING_GROUP,    minval = 10,                inline = 'swings', display=display.none)
showHighLowSwingsInput          = input.bool(   true,       'Show Strong/Weak High/Low',group = SWING_GROUP,    tooltip = showHighLowSwingsTooltip, display=display.none)

showInternalOrderBlocksInput    = input(        true,       'Internal Order Blocks' ,   group = BLOCKS_GROUP,   tooltip = showInternalOrderBlocksTooltip,   inline = 'iob', display=display.none)
internalOrderBlocksSizeInput    = input.int(    5,          '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20,                    inline = 'iob', display=display.none)
showSwingOrderBlocksInput       = input(        false,      'Swing Order Blocks',       group = BLOCKS_GROUP,   tooltip = showSwingOrderBlocksTooltip,      inline = 'ob', display=display.none)
swingOrderBlocksSizeInput       = input.int(    5,          '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20,                    inline = 'ob', display=display.none) 
orderBlockFilterInput           = input.string( 'Atr',      'Order Block Filter',       group = BLOCKS_GROUP,   tooltip = orderBlockFilterTooltip,          options = [ATR, RANGE], display=display.none)
orderBlockMitigationInput       = input.string( HIGHLOW,    'Order Block Mitigation',   group = BLOCKS_GROUP,   tooltip = orderBlockMitigationTooltip,      options = [CLOSE,HIGHLOW], display=display.none)
showBreakerBlocksInput          = input(        true,       'Show Breaker Blocks',      group = BLOCKS_GROUP,   tooltip = 'Display failed OBs that flip bias', display=display.none)
internalBullishOrderBlockColor  = input.color(color.new(#5a7a9e, 85), 'Internal Bullish OB',    group = BLOCKS_GROUP, display=display.none)
internalBearishOrderBlockColor  = input.color(color.new(#9e7a7a, 85), 'Internal Bearish OB',    group = BLOCKS_GROUP, display=display.none)
swingBullishOrderBlockColor     = input.color(color.new(#4a6a8e, 85), 'Bullish OB',             group = BLOCKS_GROUP, display=display.none)
swingBearishOrderBlockColor     = input.color(color.new(#8e6a6a, 85), 'Bearish OB',             group = BLOCKS_GROUP, display=display.none)
breakerBullishColor             = input.color(color.new(#5a8a5a, 75), 'Bullish Breaker',        group = BLOCKS_GROUP, display=display.none)
breakerBearishColor             = input.color(color.new(#8a5a5a, 75), 'Bearish Breaker',        group = BLOCKS_GROUP, display=display.none)
orderBlockExtensionBarsInput = input.int(0, "OB Extension Bars", minval=0, group=BLOCKS_GROUP, tooltip="Extend Order Blocks this many bars beyond the current bar", display=display.none)

showEqualHighsLowsInput         = input(        true,       'Equal High/Low',           group = EQUAL_GROUP,    tooltip = showEqualHighsLowsTooltip, display=display.none)
equalHighsLowsLengthInput       = input.int(    3,          'Bars Confirmation',        group = EQUAL_GROUP,    tooltip = equalHighsLowsLengthTooltip,      minval = 1, display=display.none)
equalHighsLowsThresholdInput    = input.float(  0.1,        'Threshold',                group = EQUAL_GROUP,    tooltip = equalHighsLowsThresholdTooltip,   minval = 0, maxval = 0.5, step = 0.1, display=display.none)
equalHighsLowsSizeInput         = input.string( TINY,       'Label Size',               group = EQUAL_GROUP,    options = [TINY,SMALL,NORMAL], display=display.none)

showFairValueGapsInput          = input(        false,      'Fair Value Gaps',          group = GAPS_GROUP,     tooltip = showFairValueGapsTooltip, display=display.none)
fairValueGapsThresholdInput     = input(        true,       'Auto Threshold',           group = GAPS_GROUP,     tooltip = fairValueGapsThresholdTooltip, display=display.none)
fairValueGapsTimeframeInput     = input.timeframe('',       'Timeframe',                group = GAPS_GROUP,     tooltip = fairValueGapsTimeframeTooltip, display=display.none)
fvgMitigationStyleInput         = input.string( 'Multi-Level', 'FVG Mitigation Style',  group = GAPS_GROUP,     options = ['Full', 'Multi-Level'], tooltip = 'Full: delete on any touch\nMulti-Level: track 25%, 50%, 75% fills', display=display.none)
fairValueGapsBullColorInput     = input.color(color.new(#5a8a6a, 75), 'Bullish FVG' , group = GAPS_GROUP, display=display.none)
fairValueGapsBearColorInput     = input.color(color.new(#8a6a6a, 75), 'Bearish FVG' , group = GAPS_GROUP, display=display.none)
fairValueGapsExtendInput        = input.int(    1,          'Extend FVG',               group = GAPS_GROUP,     tooltip = fairValueGapsExtendTooltip,       minval = 0, display=display.none)

showDailyLevelsInput            = input(        false,      'Daily',    group = LEVELS_GROUP,   inline = 'daily', display=display.none)
dailyLevelsStyleInput           = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'daily',   options = [SOLID,DASHED,DOTTED], display=display.none)
dailyLevelsColorInput           = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'daily', display=display.none)
showWeeklyLevelsInput           = input.bool(   false,      'Weekly',   group = LEVELS_GROUP,   inline = 'weekly', display=display.none)
weeklyLevelsStyleInput          = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'weekly',  options = [SOLID,DASHED,DOTTED], display=display.none)
weeklyLevelsColorInput          = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'weekly', display=display.none)
showMonthlyLevelsInput          = input.bool(   false,      'Monthly',   group = LEVELS_GROUP,   inline = 'monthly', display=display.none)
monthlyLevelsStyleInput         = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'monthly', options = [SOLID,DASHED,DOTTED], display=display.none)
monthlyLevelsColorInput         = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'monthly', display=display.none)

showPremiumDiscountZonesInput   = input.bool(   false,      'Premium/Discount Zones',   group = ZONES_GROUP , tooltip = showPremiumDiscountZonesTooltip, display=display.none)
showOteZonesInput               = input.bool(   false,      'Show OTE Zones (0.62-0.79)', group = ZONES_GROUP, tooltip = 'Display Optimal Trade Entry zones within premium/discount', display=display.none)
premiumZoneColorInput           = input.color(  RED,        'Premium Zone',             group = ZONES_GROUP, display=display.none)
equilibriumZoneColorInput       = input.color(  GRAY,       'Equilibrium Zone',         group = ZONES_GROUP, display=display.none)
discountZoneColorInput          = input.color(  GREEN,      'Discount Zone',            group = ZONES_GROUP, display=display.none)
oteZoneColorInput               = input.color(  color.new(#2962ff, 85), 'OTE Zone',     group = ZONES_GROUP, display=display.none)



//---------------------------------------------------------------------------------------------------------------------}
//DATA STRUCTURES & VARIABLES
//---------------------------------------------------------------------------------------------------------------------{
// @type                            UDT representing alerts as bool fields
// @field internalBullishBOS        internal structure custom alert
// @field internalBearishBOS        internal structure custom alert
// @field internalBullishCHoCH      internal structure custom alert
// @field internalBearishCHoCH      internal structure custom alert
// @field swingBullishBOS           swing structure custom alert
// @field swingBearishBOS           swing structure custom alert
// @field swingBullishCHoCH         swing structure custom alert
// @field swingBearishCHoCH         swing structure custom alert
// @field internalBullishOrderBlock internal order block custom alert
// @field internalBearishOrderBlock internal order block custom alert
// @field swingBullishOrderBlock    swing order block custom alert
// @field swingBearishOrderBlock    swing order block custom alert
// @field equalHighs                equal high low custom alert
// @field equalLows                 equal high low custom alert
// @field bullishFairValueGap       fair value gap custom alert
// @field bearishFairValueGap       fair value gap custom alert
type alerts
    bool internalBullishBOS         = false
    bool internalBearishBOS         = false
    bool internalBullishCHoCH       = false
    bool internalBearishCHoCH       = false
    bool swingBullishBOS            = false
    bool swingBearishBOS            = false
    bool swingBullishCHoCH          = false
    bool swingBearishCHoCH          = false
    bool internalBullishOrderBlock  = false
    bool internalBearishOrderBlock  = false
    bool swingBullishOrderBlock     = false
    bool swingBearishOrderBlock     = false
    bool equalHighs                 = false
    bool equalLows                  = false
    bool bullishFairValueGap        = false
    bool bearishFairValueGap        = false
    bool bullishSweep               = false
    bool bearishSweep               = false
    bool buySignal                  = false
    bool sellSignal                 = false
    bool morningSessionStart        = false
    bool afternoonSessionStart      = false

// @type                            UDT representing last swing extremes (top & bottom)
// @field top                       last top swing price
// @field bottom                    last bottom swing price
// @field barTime                   last swing bar time
// @field barIndex                  last swing bar index
// @field lastTopTime               last top swing time
// @field lastBottomTime            last bottom swing time
type trailingExtremes
    float top
    float bottom
    int barTime
    int barIndex
    int lastTopTime
    int lastBottomTime

// @type                            UDT representing Fair Value Gaps
// @field top                       top price
// @field bottom                    bottom price
// @field bias                      bias (BULLISH or BEARISH)
// @field topBox                    top box
// @field bottomBox                 bottom box
// @field mitigationLevel           0=untouched, 1=25%, 2=50%, 3=75%, 4=100%
type fairValueGap
    float top
    float bottom
    int bias
    box topBox
    box bottomBox
    int mitigationLevel = 0

// @type                            UDT representing trend bias
// @field bias                      BULLISH or BEARISH
type trend
    int bias    

// @type                            UDT representing session state
type SessionState
    int    start_ts
    int    end_ts
    bool   active
    float  high
    float  low
    float  open
    float  close
    box    boxid
    line   openLine
    line   closeLine
    label  nameLabel    

// @type                            UDT representing Equal Highs Lows display
// @field l_ine                     displayed line
// @field l_abel                    displayed label
type equalDisplay
    line l_ine      = na
    label l_abel    = na

// @type                            UDT representing a pivot point (swing point) 
// @field currentLevel              current price level
// @field lastLevel                 last price level
// @field crossed                   true if price level is crossed
// @field barTime                   bar time
// @field barIndex                  bar index    
type pivot
    float currentLevel
    float lastLevel
    bool crossed
    int barTime     = time
    int barIndex    = bar_index

// @type                            UDT representing an order block
// @field barHigh                   bar high
// @field barLow                    bar low
// @field barTime                   bar time
// @field bias                      BULLISH or BEARISH
// @field isBreaker                 true if OB became breaker block
type orderBlock
    float barHigh
    float barLow
    int barTime    
    int bias
    bool isBreaker = false

// Signal UDT - Removed (using AI for signal generation instead)

// @variable                        current swing pivot high    
var pivot swingHigh                 = pivot.new(na,na,false)
// @variable                        current swing pivot low
var pivot swingLow                  = pivot.new(na,na,false)
// @variable                        current internal pivot high
var pivot internalHigh              = pivot.new(na,na,false)
// @variable                        current internal pivot low
var pivot internalLow               = pivot.new(na,na,false)
// @variable                        current equal high pivot
var pivot equalHigh                 = pivot.new(na,na,false)
// @variable                        current equal low pivot
var pivot equalLow                  = pivot.new(na,na,false)
// @variable                        swing trend bias
var trend swingTrend                = trend.new(0)
// @variable                        internal trend bias
var trend internalTrend             = trend.new(0)
// @variable                        equal high display
var equalDisplay equalHighDisplay   = equalDisplay.new()
// @variable                        equal low display
var equalDisplay equalLowDisplay    = equalDisplay.new()
// @variable                        storage for fairValueGap UDTs
var array<fairValueGap> fairValueGaps = array.new<fairValueGap>()
// @variable                        storage for parsed highs
var array<float> parsedHighs        = array.new<float>()
// @variable                        storage for parsed lows
var array<float> parsedLows         = array.new<float>()
// @variable                        storage for raw highs
var array<float> highs              = array.new<float>()
// @variable                        storage for raw lows
var array<float> lows               = array.new<float>()
// @variable                        storage for bar time values
var array<int> times                = array.new<int>()
// @variable                        last trailing swing high and low
var trailingExtremes trailing       = trailingExtremes.new()
// @variable                                storage for orderBlock UDTs (swing order blocks)
var array<orderBlock> swingOrderBlocks      = array.new<orderBlock>()
// @variable                                storage for orderBlock UDTs (internal order blocks)
var array<orderBlock> internalOrderBlocks   = array.new<orderBlock>()
// @variable                                storage for breaker blocks
var array<orderBlock> breakerBlocks         = array.new<orderBlock>()
// @variable                                storage for swing order blocks boxes
var array<box> swingOrderBlocksBoxes        = array.new<box>()
// @variable                                storage for internal order blocks boxes
var array<box> internalOrderBlocksBoxes     = array.new<box>()
// @variable                                storage for breaker blocks boxes
var array<box> breakerBlocksBoxes           = array.new<box>()
// @variable                        color for swing bullish structures
var swingBullishColor               = styleInput == MONOCHROME ? MONO_BULLISH : swingBullColorInput
// @variable                        color for swing bearish structures
var swingBearishColor               = styleInput == MONOCHROME ? MONO_BEARISH : swingBearColorInput
// @variable                        color for bullish fair value gaps
var fairValueGapBullishColor        = styleInput == MONOCHROME ? color.new(MONO_BULLISH,70) : fairValueGapsBullColorInput
// @variable                        color for bearish fair value gaps
var fairValueGapBearishColor        = styleInput == MONOCHROME ? color.new(MONO_BEARISH,70) : fairValueGapsBearColorInput
// @variable                        color for premium zone
var premiumZoneColor                = styleInput == MONOCHROME ? MONO_BEARISH : premiumZoneColorInput
// @variable                        color for discount zone
var discountZoneColor               = styleInput == MONOCHROME ? MONO_BULLISH : discountZoneColorInput 
// @variable                        bar index on current script iteration
varip int currentBarIndex           = bar_index
// @variable                        bar index on last script iteration
varip int lastBarIndex              = bar_index
// @variable                        alerts in current bar
alerts currentAlerts                = alerts.new()

// EMA Trend Variables
var trend emaTrend                  = trend.new(0)
var trend emaHtfTrend               = trend.new(0) // Higher timeframe EMA trend

// @variable                        time at start of chart
var initialTime                     = time

// Session Management Variables
var SessionState morning   = SessionState.new(na,na,false,na,na,na,na,na,na,na,na)
var SessionState afternoon = SessionState.new(na,na,false,na,na,na,na,na,na,na,na)

// Liquidity Variables
var float atrVal = ta.atr(14)
var array<float> liquidityLevels = array.new<float>()

// Signal Variables - Removed (using AI for signal generation instead)

// HTF data for pivots/liquidity
[htfHigh, htfLow] = request.security(syminfo.tickerid, htfTimeframeInput, [high, low])
htfPivotHigh = ta.pivothigh(htfHigh, 5, 5)
htfPivotLow = ta.pivotlow(htfLow, 5, 5)

// LTF data for OB refinement
[ltfOpen, ltfHigh, ltfLow, ltfClose] = request.security(syminfo.tickerid, ltfTimeframeInput, [open, high, low, close])

// we create the needed boxes for displaying order blocks at the first execution
if barstate.isfirst
    if showSwingOrderBlocksInput
        for index = 1 to swingOrderBlocksSizeInput
            swingOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time))
    if showInternalOrderBlocksInput
        for index = 1 to internalOrderBlocksSizeInput
            internalOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time))
    if showBreakerBlocksInput
        for index = 1 to 10
            breakerBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time))

// @variable                        source to use in bearish order blocks mitigation
bearishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : high
// @variable                        source to use in bullish order blocks mitigation
bullishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : low
// @variable                        default volatility measure
atrMeasure                          = ta.atr(200)
// @variable                        parsed volatility measure by user settings
volatilityMeasure                   = orderBlockFilterInput == ATR ? atrMeasure : ta.cum(ta.tr)/bar_index

// Session Management Helper Functions
sess_start_ts(h, m) => timestamp(tz, year, month, dayofmonth, h, m)
sess_end_ts(h, m)   => timestamp(tz, year, month, dayofmonth, h, m)

// Ensure session end is after start (handle overnight sessions)
fix_end(start, end) =>
    end <= start ? end + 24*60*60*1000 : end

// EMA Helper Functions
emaGd(src, len, factor) => 
    ta.ema(src, len) * (1 + factor) - ta.ema(ta.ema(src, len), len) * factor 
emaT3(src, len, factor) => 
    emaGd(emaGd(emaGd(src, len, factor), len, factor), len, factor)

// Update a session state object
update_session(SessionState s, int start_ts, int end_ts, color bgc, string name) =>
    bool current_bar_in_session = time >= start_ts and time < end_ts
    bool prev_bar_in_session = time[1] >= start_ts and time[1] < end_ts

    bool bar_is_start = current_bar_in_session and not prev_bar_in_session
    bool bar_inside   = current_bar_in_session
    bool bar_is_end   = not current_bar_in_session and prev_bar_in_session

    // If we are inside the session, ensure it's active, even if bar_is_start didn't trigger
    if bar_inside and not s.active
        s.active := true
        s.start_ts := start_ts // Initialize start_ts if starting mid-session
        s.open := open         // Initialize open if starting mid-session
        s.high := high
        s.low := low

    if bar_is_start
        s.start_ts := start_ts
        s.end_ts := end_ts
        s.active := true
        s.open := open
        s.high := high
        s.low := low
        s.close := close

    if s.active and (bar_inside or bar_is_start) // Only draw if active and inside/start
        if bar_is_start
            s.high := high
            s.low := low
        else
            s.high := math.max(s.high, high)
            s.low := math.min(s.low, low)
        s.close := close
        
        // Always update/create the box during the session
        if not na(s.boxid)
            box.delete(s.boxid)
        s.boxid := box.new(s.start_ts, s.high, time_close, s.low, xloc=xloc.bar_time, bgcolor=bgc, border_color=color.new(bgc,60))

        if show_open_close
            if not na(s.openLine)
                line.delete(s.openLine)
            if not na(s.closeLine)
                line.delete(s.closeLine)
            s.openLine := line.new(s.start_ts, s.open, time_close, s.open, xloc=xloc.bar_time, color=color.new(color.white,70), style=line.style_dashed)
            s.closeLine := line.new(s.start_ts, s.close, time_close, s.close, xloc=xloc.bar_time, color=color.new(color.white,85), style=line.style_dotted)

    if bar_is_end and s.active
        s.active := false
    
// Initialize session times
morning_start = sess_start_ts(morning_start_h, morning_start_m)
morning_end   = fix_end(morning_start, sess_end_ts(morning_end_h, morning_end_m))
afternoon_start = sess_start_ts(afternoon_start_h, afternoon_start_m)
afternoon_end   = fix_end(afternoon_start, sess_end_ts(afternoon_end_h, afternoon_end_m))

// Update sessions
update_session(morning, morning_start, morning_end, morning_color, morning_name)
update_session(afternoon, afternoon_start, afternoon_end, afternoon_color, afternoon_name)

// EMA Trend Calculations
emaSrc = close
emaRes = emaUseCurrentRes ? timeframe.period : emaResCustom

// Hull MA
emaHullma = ta.wma(2 * ta.wma(emaSrc, emaLen/2) - ta.wma(emaSrc, emaLen), math.round(math.sqrt(emaLen)))

// TEMA
emaEma1 = ta.ema(emaSrc, emaLen)
emaEma2 = ta.ema(emaEma1, emaLen)
emaEma3 = ta.ema(emaEma2, emaLen)
emaTema = 3 * (emaEma1 - emaEma2) + emaEma3

// Tilson T3
emaTilT3 = emaT3(emaSrc, emaLen, emaFactorT3)

// Select MA Type
emaAvg = switch emaType
    1 => ta.sma(emaSrc, emaLen)
    2 => ta.ema(emaSrc, emaLen)
    3 => ta.wma(emaSrc, emaLen)
    4 => emaHullma
    5 => ta.vwma(emaSrc, emaLen)
    6 => ta.rma(emaSrc, emaLen)
    7 => emaTema
    8 => emaTilT3

// Get MA from selected timeframe
ema = request.security(syminfo.tickerid, emaRes, emaAvg, lookahead=barmerge.lookahead_off)

// EMA Trend Logic
ema_up = ema >= ema[1]
ema_down = ema < ema[1]

// Update EMA trend
if showEmaInput
    emaTrend.bias := ema_up ? BULLISH : ema_down ? BEARISH : emaTrend.bias

// EMA Colors
emaTrendColor = emaColorDirection ? (ema_up ? color.new(color.green, 0) : ema_down ? color.new(color.red, 0) : color.new(color.gray, 0)) : color.new(color.blue, 0)

// Plot EMA
plot(showEmaInput ? ema : na, title='EMA Trend', linewidth=emaLineWidth, color=emaTrendColor)

// Higher Timeframe EMA Calculations
emaHtfSrc = close
emaHtfRes = emaHtfResCustom

// Hull MA for HTF
emaHtfHullma = ta.wma(2 * ta.wma(emaHtfSrc, emaHtfLen/2) - ta.wma(emaHtfSrc, emaHtfLen), math.round(math.sqrt(emaHtfLen)))

// TEMA for HTF
emaHtfEma1 = ta.ema(emaHtfSrc, emaHtfLen)
emaHtfEma2 = ta.ema(emaHtfEma1, emaHtfLen)
emaHtfEma3 = ta.ema(emaHtfEma2, emaHtfLen)
emaHtfTema = 3 * (emaHtfEma1 - emaHtfEma2) + emaHtfEma3

// Tilson T3 for HTF
emaHtfTilT3 = emaT3(emaHtfSrc, emaHtfLen, emaHtfFactorT3)

// Select MA Type for HTF
emaHtfAvg = switch emaHtfType
    1 => ta.sma(emaHtfSrc, emaHtfLen)
    2 => ta.ema(emaHtfSrc, emaHtfLen)
    3 => ta.wma(emaHtfSrc, emaHtfLen)
    4 => emaHtfHullma
    5 => ta.vwma(emaHtfSrc, emaHtfLen)
    6 => ta.rma(emaHtfSrc, emaHtfLen)
    7 => emaHtfTema
    8 => emaHtfTilT3

// Get MA from selected higher timeframe
emaHtf = request.security(syminfo.tickerid, emaHtfRes, emaHtfAvg, lookahead=barmerge.lookahead_off)

// Higher Timeframe EMA Trend Logic
emaHtf_up = emaHtf >= emaHtf[1]
emaHtf_down = emaHtf < emaHtf[1]

// Update Higher Timeframe EMA trend
if showEmaHtfInput
    emaHtfTrend.bias := emaHtf_up ? BULLISH : emaHtf_down ? BEARISH : emaHtfTrend.bias

// Higher Timeframe EMA Colors
emaHtfTrendColor = emaHtfColorDirection ? (emaHtf_up ? color.new(color.green, 0) : emaHtf_down ? color.new(color.red, 0) : color.new(color.gray, 0)) : color.new(color.blue, 0)

// Plot Higher Timeframe EMA
plot(showEmaHtfInput ? emaHtf : na, title='Higher TF EMA Trend', linewidth=emaHtfLineWidth, color=emaHtfTrendColor)
// @variable                        true if current bar is a high volatility bar
highVolatilityBar                   = (high - low) >= (2 * volatilityMeasure)
// @variable                        parsed high
parsedHigh                          = highVolatilityBar ? low : high
// @variable                        parsed low
parsedLow                           = highVolatilityBar ? high : low

// we store current values into the arrays at each bar with size limits
if parsedHighs.size() > 5000
    parsedHighs.shift()
    parsedLows.shift()
    highs.shift()
    lows.shift()
    times.shift()
parsedHighs.push(parsedHigh)
parsedLows.push(parsedLow)
highs.push(high)
lows.push(low)
times.push(time)





//---------------------------------------------------------------------------------------------------------------------}
//USER-DEFINED FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------{
// @function            Get the value of the current leg, it can be 0 (bearish) or 1 (bullish)
// @returns             int
leg(int size) =>
    var int leg = 0    
    newLegHigh = high[size] > ta.highest(size)
    newLegLow = low[size] < ta.lowest(size)
    
    if newLegHigh
        leg := BEARISH_LEG
    else if newLegLow
        leg := BULLISH_LEG
    leg  // This is the return value

// @function            Identify whether the current value is the start of a new leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfNewLeg(int leg)      => ta.change(leg) != 0

// @function            Identify whether the current level is the start of a new bearish leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfBearishLeg(int leg)  => ta.change(leg) == -1

// @function            Identify whether the current level is the start of a new bullish leg (swing)
// @param leg           (int) Current leg value
// @returns             bool
startOfBullishLeg(int leg)  => ta.change(leg) == +1

// @function            create a new label
// @param labelTime     bar time coordinate
// @param labelPrice    price coordinate
// @param tag           text to display
// @param labelColor    text color
// @param labelStyle    label style
// @returns             label ID
drawLabel(int labelTime, float labelPrice, string tag, color labelColor, string labelStyle) =>    
    var label l_abel = na

    if modeInput == PRESENT
        l_abel.delete()

    l_abel := label.new(chart.point.new(labelTime,na,labelPrice),tag,xloc.bar_time,color=color(na),textcolor=labelColor,style = labelStyle,size = size.small)

// @function            create a new line and label representing an EQH or EQL
// @param p_ivot        starting pivot
// @param level         price level of current pivot
// @param size          how many bars ago was the current pivot detected
// @param equalHigh     true for EQH, false for EQL
// @returns             label ID
drawEqualHighLow(pivot p_ivot, float level, int size, bool equalHigh) =>
    equalDisplay e_qualDisplay = equalHigh ? equalHighDisplay : equalLowDisplay
    
    string tag          = 'EQL'
    color equalColor    = swingBullishColor
    string labelStyle   = label.style_label_up

    if equalHigh
        tag         := 'EQH'
        equalColor  := swingBearishColor
        labelStyle  := label.style_label_down

    if modeInput == PRESENT
        line.delete(    e_qualDisplay.l_ine)
        label.delete(   e_qualDisplay.l_abel)
        
    e_qualDisplay.l_ine     := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time[size],na,level), xloc = xloc.bar_time, color = equalColor, style = line.style_dotted)
    labelPosition           = math.round(0.5*(p_ivot.barIndex + bar_index - size))
    e_qualDisplay.l_abel    := label.new(chart.point.new(na,labelPosition,level), tag, xloc.bar_index, color = color(na), textcolor = equalColor, style = labelStyle, size = equalHighsLowsSizeInput)

// @function            store current structure and trailing swing points, and also display swing points and equal highs/lows
// @param size          (int) structure size
// @param equalHighLow  (bool) true for displaying current highs/lows
// @param internal      (bool) true for getting internal structures
// @returns             label ID
getCurrentStructure(int size,bool equalHighLow = false, bool internal = false) =>        
    currentLeg              = leg(size)
    newPivot                = startOfNewLeg(currentLeg)
    pivotLow                = startOfBullishLeg(currentLeg)
    pivotHigh               = startOfBearishLeg(currentLeg)

    if newPivot
        if pivotLow
            pivot p_ivot    = equalHighLow ? equalLow : internal ? internalLow : swingLow    

            if equalHighLow and math.abs(p_ivot.currentLevel - low[size]) < equalHighsLowsThresholdInput * atrMeasure                
                drawEqualHighLow(p_ivot, low[size], size, false)

            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := low[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]

            if not equalHighLow and not internal
                trailing.bottom         := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastBottomTime := p_ivot.barTime

            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel < p_ivot.lastLevel ? 'LL' : 'HL', swingBullishColor, label.style_label_up)            
        else
            pivot p_ivot = equalHighLow ? equalHigh : internal ? internalHigh : swingHigh

            if equalHighLow and math.abs(p_ivot.currentLevel - high[size]) < equalHighsLowsThresholdInput * atrMeasure
                drawEqualHighLow(p_ivot,high[size],size,true)                

            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := high[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]

            if not equalHighLow and not internal
                trailing.top            := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastTopTime    := p_ivot.barTime

            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel > p_ivot.lastLevel ? 'HH' : 'LH', swingBearishColor, label.style_label_down)
                
// @function                draw line and label representing a structure
// @param p_ivot            base pivot point
// @param tag               test to display
// @param structureColor    base color
// @param lineStyle         line style
// @param labelStyle        label style
// @param labelSize         text size
// @returns                 label ID
drawStructure(pivot p_ivot, string tag, color structureColor, string lineStyle, string labelStyle, string labelSize) =>    
    var line l_ine      = line.new(na,na,na,na,xloc = xloc.bar_time)
    var label l_abel    = label.new(na,na)

    if modeInput == PRESENT
        l_ine.delete()
        l_abel.delete()

    l_ine   := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time,na,p_ivot.currentLevel), xloc.bar_time, color=structureColor, style=lineStyle)
    l_abel  := label.new(chart.point.new(na,math.round(0.5*(p_ivot.barIndex+bar_index)),p_ivot.currentLevel), tag, xloc.bar_index, color=color(na), textcolor=structureColor, style=labelStyle, size = labelSize)

// @function            delete order blocks and detect breaker blocks
// @param internal      true for internal order blocks
// @returns             orderBlock ID
deleteOrderBlocks(bool internal = false) =>
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks

    for [index,eachOrderBlock] in orderBlocks
        bool crossedOderBlock = false
        bool becameBreaker = false
        
        if bearishOrderBlockMitigationSource > eachOrderBlock.barHigh and eachOrderBlock.bias == BEARISH
            crossedOderBlock := true
            // Check if price fully broke through (breaker block)
            if close < eachOrderBlock.barLow and showBreakerBlocksInput
                becameBreaker := true
                eachOrderBlock.isBreaker := true
                eachOrderBlock.bias := BULLISH  // Flip bias
                if breakerBlocks.size() < 50
                    breakerBlocks.unshift(eachOrderBlock)
            if internal
                currentAlerts.internalBearishOrderBlock := true
            else
                currentAlerts.swingBearishOrderBlock    := true
        else if bullishOrderBlockMitigationSource < eachOrderBlock.barLow and eachOrderBlock.bias == BULLISH
            crossedOderBlock := true
            // Check if price fully broke through (breaker block)
            if close > eachOrderBlock.barHigh and showBreakerBlocksInput
                becameBreaker := true
                eachOrderBlock.isBreaker := true
                eachOrderBlock.bias := BEARISH  // Flip bias
                if breakerBlocks.size() < 50
                    breakerBlocks.unshift(eachOrderBlock)
            if internal
                currentAlerts.internalBullishOrderBlock := true
            else
                currentAlerts.swingBullishOrderBlock    := true
        if crossedOderBlock and not becameBreaker                    
            orderBlocks.remove(index)            

// @function            fetch and store order blocks with optional LTF refinement
// @param p_ivot        base pivot point
// @param internal      true for internal order blocks
// @param bias          BULLISH or BEARISH
// @returns             void
storeOrdeBlock(pivot p_ivot,bool internal = false,int bias) =>
    if (not internal and showSwingOrderBlocksInput) or (internal and showInternalOrderBlocksInput)

        array<float> a_rray = na
        int parsedIndex = na
        
        // Calculate safe array indices accounting for array size limit
        int arraySize = parsedHighs.size()
        int startIdx = math.max(0, bar_index - arraySize)
        int pivotArrayIdx = p_ivot.barIndex - startIdx
        int currentArrayIdx = bar_index - startIdx
        
        // Only proceed if indices are valid
        if pivotArrayIdx >= 0 and pivotArrayIdx < arraySize and currentArrayIdx <= arraySize
            if bias == BEARISH
                a_rray      := parsedHighs.slice(pivotArrayIdx, currentArrayIdx)
                parsedIndex := pivotArrayIdx + a_rray.indexof(a_rray.max())  
            else
                a_rray      := parsedLows.slice(pivotArrayIdx, currentArrayIdx)
                parsedIndex := pivotArrayIdx + a_rray.indexof(a_rray.min())
        
            // LTF Refinement: Find last opposing candle before structure break
            float obHigh = parsedHighs.get(parsedIndex)
            float obLow = parsedLows.get(parsedIndex)
            
            if useLtfRefinementInput
                // Use LTF data to refine the OB to the last opposing candle
                if bias == BEARISH
                    // For bearish OB, find last bullish LTF candle
                    if ltfClose > ltfOpen
                        obHigh := math.max(obHigh, ltfHigh)
                        obLow := math.max(obLow, ltfLow)
                else
                    // For bullish OB, find last bearish LTF candle
                    if ltfClose < ltfOpen
                        obHigh := math.min(obHigh, ltfHigh)
                        obLow := math.min(obLow, ltfLow)

            orderBlock o_rderBlock          = orderBlock.new(obHigh, obLow, times.get(parsedIndex), bias)
            array<orderBlock> orderBlocks   = internal ? internalOrderBlocks : swingOrderBlocks
            
            if orderBlocks.size() >= 100
                orderBlocks.pop()
            orderBlocks.unshift(o_rderBlock)

// @function            draw order blocks as boxes
// @param internal      true for internal order blocks
// @returns             void
drawOrderBlocks(bool internal = false) =>        
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
    orderBlocksSize = orderBlocks.size()
    if orderBlocksSize > 0        
        maxOrderBlocks                      = internal ? internalOrderBlocksSizeInput : swingOrderBlocksSizeInput
        array<orderBlock> parsedOrdeBlocks  = orderBlocks.slice(0, math.min(maxOrderBlocks,orderBlocksSize))
        array<box> b_oxes                   = internal ? internalOrderBlocksBoxes : swingOrderBlocksBoxes        
        boxEndTime = last_bar_time + (orderBlockExtensionBarsInput * (time - time[1]))
        for [index,eachOrderBlock] in parsedOrdeBlocks
            orderBlockColor = styleInput == MONOCHROME ? (eachOrderBlock.bias == BEARISH ? color.new(MONO_BEARISH,80) : color.new(MONO_BULLISH,80)) : internal ? (eachOrderBlock.bias == BEARISH ? internalBearishOrderBlockColor : internalBullishOrderBlockColor) : (eachOrderBlock.bias == BEARISH ? swingBearishOrderBlockColor : swingBullishOrderBlockColor)
            box b_ox        = b_oxes.get(index)
            b_ox.set_left(eachOrderBlock.barTime)
            b_ox.set_top(eachOrderBlock.barHigh)
            b_ox.set_right(boxEndTime)
            b_ox.set_bottom(eachOrderBlock.barLow)
            b_ox.set_bgcolor(orderBlockColor)
            b_ox.set_border_color(color.new(orderBlockColor, 60))

// @function            draw breaker blocks as boxes
// @returns             void
drawBreakerBlocks() =>
    breakerBlocksSize = breakerBlocks.size()
    if breakerBlocksSize > 0 and showBreakerBlocksInput
        maxBreakers = math.min(10, breakerBlocksSize)
        array<orderBlock> parsedBreakers = breakerBlocks.slice(0, maxBreakers)
        boxEndTime = last_bar_time + (orderBlockExtensionBarsInput * (time - time[1]))
        for [index,eachBreaker] in parsedBreakers
            if index < breakerBlocksBoxes.size()
                breakerColor = eachBreaker.bias == BULLISH ? breakerBullishColor : breakerBearishColor
                box b_ox = breakerBlocksBoxes.get(index)
                b_ox.set_left(eachBreaker.barTime)
                b_ox.set_top(eachBreaker.barHigh)
                b_ox.set_right(boxEndTime)
                b_ox.set_bottom(eachBreaker.barLow)
                b_ox.set_bgcolor(color.new(breakerColor, 100))  // Transparent background
                b_ox.set_border_color(color.new(breakerColor, 0))  // Solid border
                b_ox.set_border_style(line.style_dashed)
                b_ox.set_border_width(2)


// @function            detect and draw structures, also detect and store order blocks
// @param internal      true for internal structures or order blocks
// @returns             void
displayStructure(bool internal = false) =>
    var bullishBar = true
    var bearishBar = true

    if internalFilterConfluenceInput
        bullishBar := high - math.max(close, open) > math.min(close, open - low)
        bearishBar := high - math.max(close, open) < math.min(close, open - low)
    
    pivot p_ivot    = internal ? internalHigh : swingHigh
    trend t_rend    = internal ? internalTrend : swingTrend

    lineStyle       = internal ? line.style_dashed : line.style_solid
    labelSize       = internal ? internalStructureSize : swingStructureSize

    extraCondition  = internal ? internalHigh.currentLevel != swingHigh.currentLevel and bullishBar : true
    bullishColor    = styleInput == MONOCHROME ? MONO_BULLISH : internal ? internalBullColorInput : swingBullColorInput

    if ta.crossover(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BEARISH ? CHOCH : BOS

        if internal
            currentAlerts.internalBullishCHoCH  := tag == CHOCH
            currentAlerts.internalBullishBOS    := tag == BOS
        else
            currentAlerts.swingBullishCHoCH     := tag == CHOCH
            currentAlerts.swingBullishBOS       := tag == BOS

        p_ivot.crossed  := true
        t_rend.bias     := BULLISH

        displayCondition = internal ? showInternalsInput and (showInternalBullInput == ALL or (showInternalBullInput == BOS and tag != CHOCH) or (showInternalBullInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBullInput == ALL or (showSwingBullInput == BOS and tag != CHOCH) or (showSwingBullInput == CHOCH and tag == CHOCH))

        if displayCondition
            drawStructure(p_ivot,tag,bullishColor,lineStyle,label.style_label_down,labelSize)

        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BULLISH)

    p_ivot          := internal ? internalLow : swingLow    
    extraCondition  := internal ? internalLow.currentLevel != swingLow.currentLevel and bearishBar : true
    bearishColor    = styleInput == MONOCHROME ? MONO_BEARISH : internal ? internalBearColorInput : swingBearColorInput

    if ta.crossunder(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BULLISH ? CHOCH : BOS

        if internal
            currentAlerts.internalBearishCHoCH  := tag == CHOCH
            currentAlerts.internalBearishBOS    := tag == BOS
        else
            currentAlerts.swingBearishCHoCH     := tag == CHOCH
            currentAlerts.swingBearishBOS       := tag == BOS

        p_ivot.crossed := true
        t_rend.bias := BEARISH

        displayCondition = internal ? showInternalsInput and (showInternalBearInput == ALL or (showInternalBearInput == BOS and tag != CHOCH) or (showInternalBearInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBearInput == ALL or (showSwingBearInput == BOS and tag != CHOCH) or (showSwingBearInput == CHOCH and tag == CHOCH))
        
        if displayCondition
            drawStructure(p_ivot,tag,bearishColor,lineStyle,label.style_label_up,labelSize)

        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BEARISH)

// @function            draw one fair value gap box (each fair value gap has two boxes)
// @param leftTime      left time coordinate
// @param rightTime     right time coordinate
// @param topPrice      top price level
// @param bottomPrice   bottom price level
// @param boxColor      box color
// @returns             box ID
fairValueGapBox(leftTime,rightTime,topPrice,bottomPrice,boxColor) => box.new(chart.point.new(leftTime,na,topPrice),chart.point.new(rightTime + fairValueGapsExtendInput * (time-time[1]),na,bottomPrice), xloc=xloc.bar_time, border_color = boxColor, bgcolor = boxColor)

// @function            delete or update fair value gaps with multi-level mitigation
// @returns             void
deleteFairValueGaps() =>
    for [index,eachFairValueGap] in fairValueGaps
        fvgRange = eachFairValueGap.top - eachFairValueGap.bottom
        bool shouldRemove = false
        
        if fvgMitigationStyleInput == 'Full'
            // Original logic: delete on any touch
            if (low < eachFairValueGap.bottom and eachFairValueGap.bias == BULLISH) or (high > eachFairValueGap.top and eachFairValueGap.bias == BEARISH)
                eachFairValueGap.topBox.delete()
                eachFairValueGap.bottomBox.delete()
                shouldRemove := true
        else
            // Multi-level mitigation tracking
            if eachFairValueGap.bias == BULLISH
                penetration = eachFairValueGap.top - low
                fillPercent = penetration / fvgRange
                
                if fillPercent >= 1.0 and eachFairValueGap.mitigationLevel < 4
                    eachFairValueGap.mitigationLevel := 4
                    eachFairValueGap.topBox.delete()
                    eachFairValueGap.bottomBox.delete()
                    shouldRemove := true
                else if fillPercent >= 0.75 and eachFairValueGap.mitigationLevel < 3
                    eachFairValueGap.mitigationLevel := 3
                    eachFairValueGap.topBox.set_bgcolor(color.new(fairValueGapBullishColor, 85))
                    eachFairValueGap.bottomBox.set_bgcolor(color.new(fairValueGapBullishColor, 85))
                else if fillPercent >= 0.50 and eachFairValueGap.mitigationLevel < 2
                    eachFairValueGap.mitigationLevel := 2
                    eachFairValueGap.topBox.set_bgcolor(color.new(fairValueGapBullishColor, 80))
                    eachFairValueGap.bottomBox.set_bgcolor(color.new(fairValueGapBullishColor, 80))
                else if fillPercent >= 0.25 and eachFairValueGap.mitigationLevel < 1
                    eachFairValueGap.mitigationLevel := 1
                    eachFairValueGap.topBox.set_bgcolor(color.new(fairValueGapBullishColor, 75))
                    eachFairValueGap.bottomBox.set_bgcolor(color.new(fairValueGapBullishColor, 75))
            else
                penetration = high - eachFairValueGap.bottom
                fillPercent = penetration / fvgRange
                
                if fillPercent >= 1.0 and eachFairValueGap.mitigationLevel < 4
                    eachFairValueGap.mitigationLevel := 4
                    eachFairValueGap.topBox.delete()
                    eachFairValueGap.bottomBox.delete()
                    shouldRemove := true
                else if fillPercent >= 0.75 and eachFairValueGap.mitigationLevel < 3
                    eachFairValueGap.mitigationLevel := 3
                    eachFairValueGap.topBox.set_bgcolor(color.new(fairValueGapBearishColor, 85))
                    eachFairValueGap.bottomBox.set_bgcolor(color.new(fairValueGapBearishColor, 85))
                else if fillPercent >= 0.50 and eachFairValueGap.mitigationLevel < 2
                    eachFairValueGap.mitigationLevel := 2
                    eachFairValueGap.topBox.set_bgcolor(color.new(fairValueGapBearishColor, 80))
                    eachFairValueGap.bottomBox.set_bgcolor(color.new(fairValueGapBearishColor, 80))
                else if fillPercent >= 0.25 and eachFairValueGap.mitigationLevel < 1
                    eachFairValueGap.mitigationLevel := 1
                    eachFairValueGap.topBox.set_bgcolor(color.new(fairValueGapBearishColor, 75))
                    eachFairValueGap.bottomBox.set_bgcolor(color.new(fairValueGapBearishColor, 75))
        
        if shouldRemove
            fairValueGaps.remove(index)
    
// @function            draw fair value gaps
// @returns             fairValueGap ID
drawFairValueGaps() => 
    [lastClose, lastOpen, lastTime, currentHigh, currentLow, currentTime, last2High, last2Low] = request.security(syminfo.tickerid, fairValueGapsTimeframeInput, [close[1], open[1], time[1], high[0], low[0], time[0], high[2], low[2]],lookahead = barmerge.lookahead_on)

    barDeltaPercent     = (lastClose - lastOpen) / (lastOpen * 100)
    newTimeframe        = timeframe.change(fairValueGapsTimeframeInput)
    threshold           = fairValueGapsThresholdInput ? ta.cum(math.abs(newTimeframe ? barDeltaPercent : 0)) / bar_index * 2 : 0

    bullishFairValueGap = currentLow > last2High and lastClose > last2High and barDeltaPercent > threshold and newTimeframe
    bearishFairValueGap = currentHigh < last2Low and lastClose < last2Low and -barDeltaPercent > threshold and newTimeframe

    if bullishFairValueGap
        currentAlerts.bullishFairValueGap := true
        fairValueGaps.unshift(fairValueGap.new(currentLow,last2High,BULLISH,fairValueGapBox(lastTime,currentTime,currentLow,math.avg(currentLow,last2High),fairValueGapBullishColor),fairValueGapBox(lastTime,currentTime,math.avg(currentLow,last2High),last2High,fairValueGapBullishColor)))
    if bearishFairValueGap
        currentAlerts.bearishFairValueGap := true
        fairValueGaps.unshift(fairValueGap.new(currentHigh,last2Low,BEARISH,fairValueGapBox(lastTime,currentTime,currentHigh,math.avg(currentHigh,last2Low),fairValueGapBearishColor),fairValueGapBox(lastTime,currentTime,math.avg(currentHigh,last2Low),last2Low,fairValueGapBearishColor)))

// @function            get line style from string
// @param style         line style
// @returns             string
getStyle(string style) =>
    switch style
        SOLID => line.style_solid
        DASHED => line.style_dashed
        DOTTED => line.style_dotted

// @function            draw MultiTimeFrame levels
// @param timeframe     base timeframe
// @param sameTimeframe true if chart timeframe is same as base timeframe
// @param style         line style
// @param levelColor    line and text color
// @returns             void
drawLevels(string timeframe, bool sameTimeframe, string style, color levelColor) =>
    [topLevel, bottomLevel, leftTime, rightTime] = request.security(syminfo.tickerid, timeframe, [high[1], low[1], time[1], time],lookahead = barmerge.lookahead_on)

    float parsedTop         = sameTimeframe ? high : topLevel
    float parsedBottom      = sameTimeframe ? low : bottomLevel    

    int parsedLeftTime      = sameTimeframe ? time : leftTime
    int parsedRightTime     = sameTimeframe ? time : rightTime

    int parsedTopTime       = time
    int parsedBottomTime    = time

    if not sameTimeframe
        int leftIndex               = times.binary_search_rightmost(parsedLeftTime)
        int rightIndex              = times.binary_search_rightmost(parsedRightTime)

        array<int> timeArray        = times.slice(leftIndex,rightIndex)
        array<float> topArray       = highs.slice(leftIndex,rightIndex)
        array<float> bottomArray    = lows.slice(leftIndex,rightIndex)

        parsedTopTime               := timeArray.size() > 0 ? timeArray.get(topArray.indexof(topArray.max())) : initialTime
        parsedBottomTime            := timeArray.size() > 0 ? timeArray.get(bottomArray.indexof(bottomArray.min())) : initialTime

    var line topLine        = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = getStyle(style))
    var line bottomLine     = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = getStyle(style))
    var label topLabel      = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}H',timeframe), color=color(na), textcolor = levelColor, size = size.small, style = label.style_label_left)
    var label bottomLabel   = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}L',timeframe), color=color(na), textcolor = levelColor, size = size.small, style = label.style_label_left)

    topLine.set_first_point(    chart.point.new(parsedTopTime,na,parsedTop))
    topLine.set_second_point(   chart.point.new(time_close,na,parsedTop))   
    topLabel.set_point(         chart.point.new(time_close,na,parsedTop))

    bottomLine.set_first_point( chart.point.new(parsedBottomTime,na,parsedBottom))    
    bottomLine.set_second_point(chart.point.new(time_close,na,parsedBottom))
    bottomLabel.set_point(      chart.point.new(time_close,na,parsedBottom))

// @function            true if chart timeframe is higher than provided timeframe
// @param timeframe     timeframe to check
// @returns             bool
higherTimeframe(string timeframe) => timeframe.in_seconds() > timeframe.in_seconds(timeframe)

// @function            update trailing swing points
// @returns             int
updateTrailingExtremes() =>
    trailing.top            := math.max(high,trailing.top)
    trailing.lastTopTime    := trailing.top == high ? time : trailing.lastTopTime
    trailing.bottom         := math.min(low,trailing.bottom)
    trailing.lastBottomTime := trailing.bottom == low ? time : trailing.lastBottomTime

// @function            draw trailing swing points
// @returns             void
drawHighLowSwings() =>
    var line topLine        = line.new(na, na, na, na, color = swingBearishColor, xloc = xloc.bar_time)
    var line bottomLine     = line.new(na, na, na, na, color = swingBullishColor, xloc = xloc.bar_time)
    var label topLabel      = label.new(na, na, color=color(na), textcolor = swingBearishColor, xloc = xloc.bar_time, style = label.style_label_down, size = size.tiny)
    var label bottomLabel   = label.new(na, na, color=color(na), textcolor = swingBullishColor, xloc = xloc.bar_time, style = label.style_label_up, size = size.tiny)

    topLine.set_first_point(    chart.point.new(trailing.lastTopTime, na, trailing.top))
    topLine.set_second_point(   chart.point.new(time_close, na, trailing.top))
    topLabel.set_point(         chart.point.new(time_close, na, trailing.top))
    topLabel.set_text(          swingTrend.bias == BEARISH ? 'Strong High' : 'Weak High')

    bottomLine.set_first_point( chart.point.new(trailing.lastBottomTime, na, trailing.bottom))
    bottomLine.set_second_point(chart.point.new(time_close, na, trailing.bottom))
    bottomLabel.set_point(      chart.point.new(time_close, na, trailing.bottom))
    bottomLabel.set_text(       swingTrend.bias == BULLISH ? 'Strong Low' : 'Weak Low')

// @function            draw a zone with a label and a box
// @param labelLevel    price level for label
// @param labelIndex    bar index for label
// @param top           top price level for box
// @param bottom        bottom price level for box
// @param tag           text to display
// @param zoneColor     base color
// @param style         label style
// @returns             void
drawZone(float labelLevel, int labelIndex, float top, float bottom, string tag, color zoneColor, string style) =>
    var label l_abel    = label.new(na,na,text = tag, color=color(na),textcolor = zoneColor, style = style, size = size.small)
    var box b_ox        = box.new(na,na,na,na,bgcolor = color.new(zoneColor,80),border_color = color(na), xloc = xloc.bar_time)

    b_ox.set_left(trailing.barTime)
    b_ox.set_top(top)
    b_ox.set_right(time_close)
    b_ox.set_bottom(bottom)

    l_abel.set_point(           chart.point.new(na,labelIndex,labelLevel))

// @function            draw premium/discount zones with optional OTE
// @returns             void
drawPremiumDiscountZones() =>
    priceRange = trailing.top - trailing.bottom
    
    drawZone(trailing.top, math.round(0.5*(trailing.barIndex + last_bar_index)), trailing.top, 0.95*trailing.top + 0.05*trailing.bottom, 'Premium', premiumZoneColor, label.style_label_down)

    equilibriumLevel = math.avg(trailing.top, trailing.bottom)
    drawZone(equilibriumLevel, last_bar_index, 0.525*trailing.top + 0.475*trailing.bottom, 0.525*trailing.bottom + 0.475*trailing.top, 'Equilibrium', equilibriumZoneColorInput, label.style_label_left)

    drawZone(trailing.bottom, math.round(0.5*(trailing.barIndex + last_bar_index)), 0.95*trailing.bottom + 0.05*trailing.top, trailing.bottom, 'Discount', discountZoneColor, label.style_label_up)
    
    // OTE Zones (0.62-0.79 Fibonacci retracement)
    if showOteZonesInput
        oteHigh = trailing.bottom + 0.79 * priceRange  // 79% from bottom
        oteLow = trailing.bottom + 0.62 * priceRange   // 62% from bottom
        drawZone(math.avg(oteHigh, oteLow), last_bar_index, oteHigh, oteLow, 'OTE', oteZoneColorInput, label.style_label_left)

// @function            true if current price is in the discount zone
// @returns             bool
inDiscountZone() =>
    priceRange = trailing.top - trailing.bottom
    discountZoneTop = trailing.bottom + 0.05 * priceRange // 5% from bottom
    discountZoneBottom = trailing.bottom
    close >= discountZoneBottom and close <= discountZoneTop

// @function            true if current price is in the premium zone
// @returns             bool
inPremiumZone() =>
    priceRange = trailing.top - trailing.bottom
    premiumZoneTop = trailing.top
    premiumZoneBottom = trailing.top - 0.05 * priceRange // 5% from top
    close <= premiumZoneTop and close >= premiumZoneBottom

// @function            collect liquidity levels from sessions, EQH/EQL, FVG, HTF pivots
// @returns             void
collectLiquidityLevels() =>
    array.clear(liquidityLevels)
    // Session highs/lows
    if not na(morning.high)
        array.push(liquidityLevels, morning.high)
        array.push(liquidityLevels, morning.low)
    if not na(afternoon.high)
        array.push(liquidityLevels, afternoon.high)
        array.push(liquidityLevels, afternoon.low)
    // Equal highs/lows
    if not na(equalHigh.currentLevel)
        array.push(liquidityLevels, equalHigh.currentLevel)
    if not na(equalLow.currentLevel)
        array.push(liquidityLevels, equalLow.currentLevel)
    // Fair value gaps (50% level)
    if fairValueGaps.size() > 0
        lastFVG = fairValueGaps.get(0)
        array.push(liquidityLevels, math.avg(lastFVG.top, lastFVG.bottom))
    // HTF pivots
    if not na(htfPivotHigh)
        array.push(liquidityLevels, htfPivotHigh)
    if not na(htfPivotLow)
        array.push(liquidityLevels, htfPivotLow)
    // Recent swing highs/lows for additional liquidity
    if not na(swingHigh.currentLevel)
        array.push(liquidityLevels, swingHigh.currentLevel)
    if not na(swingLow.currentLevel)
        array.push(liquidityLevels, swingLow.currentLevel)

// @function            detect liquidity sweeps (wick-through-and-reject logic)
// @returns             void
detectSweeps() =>
    if showLiquiditySweepsInput and liquidityLevels.size() > 0
        for level in liquidityLevels
            sweepDist = atrVal * sweepThresholdInput
            // Bullish sweep: wick below level, close back above
            if low < level and low < level - sweepDist and close > level
                currentAlerts.bullishSweep := true
                if showSweepLabelsInput
                    label.new(bar_index, low, '↑ Sweep', style=label.style_label_up, color=GREEN, textcolor=color.white, size=size.tiny)
            // Bearish sweep: wick above level, close back below
            if high > level and high > level + sweepDist and close < level
                currentAlerts.bearishSweep := true
                if showSweepLabelsInput
                    label.new(bar_index, high, '↓ Sweep', style=label.style_label_down, color=RED, textcolor=color.white, size=size.tiny)

//---------------------------------------------------------------------------------------------------------------------}
//MUTABLE VARIABLES & EXECUTION
//---------------------------------------------------------------------------------------------------------------------{
parsedOpen  = showTrendInput ? open : na
candleColor = internalTrend.bias == BULLISH ? swingBullishColor : swingBearishColor
plotcandle(parsedOpen,high,low,close,color = candleColor, wickcolor = candleColor, bordercolor = candleColor)

if showHighLowSwingsInput or showPremiumDiscountZonesInput
    updateTrailingExtremes()

    if showHighLowSwingsInput
        drawHighLowSwings()

    if showPremiumDiscountZonesInput
        drawPremiumDiscountZones()

// Liquidity Execution
collectLiquidityLevels()
detectSweeps()

if showFairValueGapsInput
    deleteFairValueGaps()

getCurrentStructure(swingsLengthInput,false)
getCurrentStructure(5,false,true)

if showEqualHighsLowsInput
    getCurrentStructure(equalHighsLowsLengthInput,true)

if showInternalsInput or showInternalOrderBlocksInput or showTrendInput
    displayStructure(true)


if showStructureInput or showSwingOrderBlocksInput or showHighLowSwingsInput
    displayStructure()


if showInternalOrderBlocksInput
    deleteOrderBlocks(true)

if showSwingOrderBlocksInput
    deleteOrderBlocks()

if showFairValueGapsInput
    drawFairValueGaps()

// Strategy Entry/Exit Logic (EMA-only for testing)
float takeProfit = na
float stopLoss = na

// Buy when EMA turns up and Higher Timeframe EMA is bullish
if enableBuySignals and ema_up and not ema_up[1] and emaHtfTrend.bias == BULLISH
    strategy.entry('Buy', strategy.long, comment='EMA Buy Signal')
    takeProfit := close + (atrVal * 2) // 2x ATR Take Profit
    stopLoss := close - (atrVal * 1)   // 1x ATR Stop Loss
    strategy.exit('Exit Buy', from_entry='Buy', stop=stopLoss, limit=takeProfit)

// Sell when EMA turns down and Higher Timeframe EMA is bearish
if enableSellSignals and ema_down and not ema_down[1] and emaHtfTrend.bias == BEARISH
    strategy.entry('Sell', strategy.short, comment='EMA Sell Signal')
    takeProfit := close - (atrVal * 2) // 2x ATR Take Profit
    stopLoss := close + (atrVal * 1)   // 1x ATR Stop Loss
    strategy.exit('Exit Sell', from_entry='Sell', stop=stopLoss, limit=takeProfit)

// Draw Order Blocks and Breaker Blocks
if barstate.islastconfirmedhistory or barstate.islast
    if showInternalOrderBlocksInput        
        drawOrderBlocks(true)
    if showSwingOrderBlocksInput        
        drawOrderBlocks()
    if showBreakerBlocksInput
        drawBreakerBlocks()

lastBarIndex    := currentBarIndex
currentBarIndex := bar_index
newBar          = currentBarIndex != lastBarIndex

if barstate.islastconfirmedhistory or (barstate.isrealtime and newBar)
    if showDailyLevelsInput and not higherTimeframe('D')
        drawLevels('D',timeframe.isdaily,dailyLevelsStyleInput,dailyLevelsColorInput)

    if showWeeklyLevelsInput and not higherTimeframe('W')
        drawLevels('W',timeframe.isweekly,weeklyLevelsStyleInput,weeklyLevelsColorInput)

    if showMonthlyLevelsInput and not higherTimeframe('M')
        drawLevels('M',timeframe.ismonthly,monthlyLevelsStyleInput,monthlyLevelsColorInput)

//---------------------------------------------------------------------------------------------------------------------}
//ALERTS
//---------------------------------------------------------------------------------------------------------------------{
// One-time test alert
alert("Pine Script is running and alerts are active!", alert.freq_once_per_bar_close)

alertcondition(currentAlerts.internalBullishBOS,        'Internal Bullish BOS',         'Internal Bullish BOS formed')
alertcondition(currentAlerts.internalBullishCHoCH,      'Internal Bullish CHoCH',       'Internal Bullish CHoCH formed')
alertcondition(currentAlerts.internalBearishBOS,        'Internal Bearish BOS',         'Internal Bearish BOS formed')
alertcondition(currentAlerts.internalBearishCHoCH,      'Internal Bearish CHoCH',       'Internal Bearish CHoCH formed')

alertcondition(currentAlerts.swingBullishBOS,           'Bullish BOS',                  'Bullish BOS formed')
alertcondition(currentAlerts.swingBullishCHoCH,         'Bullish CHoCH',                'Bullish CHoCH formed')
alertcondition(currentAlerts.swingBearishBOS,           'Bearish BOS',                  'Bearish BOS formed')
alertcondition(currentAlerts.swingBearishCHoCH,         'Bearish CHoCH',                'Bearish CHoCH formed')

alertcondition(currentAlerts.internalBullishOrderBlock, 'Bullish Internal OB Breakout', 'Price broke bullish internal OB')
alertcondition(currentAlerts.internalBearishOrderBlock, 'Bearish Internal OB Breakout', 'Price broke bearish internal OB')
alertcondition(currentAlerts.swingBullishOrderBlock,    'Bullish Swing OB Breakout',    'Price broke bullish swing OB')
alertcondition(currentAlerts.swingBearishOrderBlock,    'Bearish Swing OB Breakout',    'Price broke bearish swing OB')

alertcondition(currentAlerts.equalHighs,                'Equal Highs',                  'Equal highs detected')
alertcondition(currentAlerts.equalLows,                 'Equal Lows',                   'Equal lows detected')

alertcondition(currentAlerts.bullishFairValueGap,       'Bullish FVG',                  'Bullish FVG formed')
alertcondition(currentAlerts.bearishFairValueGap,       'Bearish FVG',                  'Bearish FVG formed')

// Liquidity Sweep Alerts
alertcondition(currentAlerts.bullishSweep, 'Bullish Sweep', 'Bullish liquidity sweep detected')
alertcondition(currentAlerts.bearishSweep, 'Bearish Sweep', 'Bearish liquidity sweep detected')

// EMA Trend Alerts
ema_trend_up = showEmaInput and emaTrend.bias == BULLISH and (emaTrend[1]).bias != BULLISH
ema_trend_down = showEmaInput and emaTrend.bias == BEARISH and (emaTrend[1]).bias != BEARISH
alertcondition(ema_trend_up, 'EMA Trend Up', 'EMA trend turned bullish')
alertcondition(ema_trend_down, 'EMA Trend Down', 'EMA trend turned bearish')

// Higher Timeframe EMA Trend Alerts
ema_htf_trend_up = showEmaHtfInput and emaHtfTrend.bias == BULLISH and (emaHtfTrend[1]).bias != BULLISH
ema_htf_trend_down = showEmaHtfInput and emaHtfTrend.bias == BEARISH and (emaHtfTrend[1]).bias != BEARISH
alertcondition(ema_htf_trend_up, 'Higher TF EMA Trend Up', 'Higher TF EMA trend turned bullish')
alertcondition(ema_htf_trend_down, 'Higher TF EMA Trend Down', 'Higher TF EMA trend turned bearish')

// Signal Alerts
alertcondition(currentAlerts.buySignal, 'Buy Signal', 'Buy signal generated: EMA Trend Up (LTF) and EMA Trend Up (HTF)')
alertcondition(currentAlerts.sellSignal, 'Sell Signal', 'Sell signal generated: EMA Trend Down (LTF) and EMA Trend Down (HTF)')


//---------------------------------------------------------------------------------------------------------------------}
