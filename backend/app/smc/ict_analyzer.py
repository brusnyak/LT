"""
Inner Circle Trader (ICT) concepts analysis module
"""

import logging
import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple
from datetime import datetime, time
import pytz

logger = logging.getLogger(__name__)

class ICTAnalyzer:
    """
    Analyzer for Inner Circle Trader (ICT) concepts
    """
    
    def __init__(self):
        """Initialize the ICT analyzer"""
        pass
    
    def analyze_chart(self, df: pd.DataFrame, symbol: str = None, timeframe: str = None) -> Dict:
        """
        Analyze a price chart using ICT methodology
        
        Args:
            df (pd.DataFrame): OHLCV dataframe
            symbol (str, optional): Symbol being analyzed
            timeframe (str, optional): Timeframe of the data
            
        Returns:
            dict: Analysis results
        """
        try:
            logger.info(f"Starting ICT analysis for {symbol} on {timeframe} with {len(df)} candles")
            
            # Ensure dataframe has required columns
            required_columns = ['open', 'high', 'low', 'close', 'volume']
            if not all(col.lower() in df.columns for col in required_columns):
                logger.error(f"Dataframe missing required columns. Available: {df.columns}")
                return {'error': 'Missing required columns in dataframe'}
            
            # Standardize column names to lowercase
            df.columns = [col.lower() for col in df.columns]
            
            # Ensure index is datetime and localized to UTC
            if not isinstance(df.index, pd.DatetimeIndex):
                df.index = pd.to_datetime(df.index, utc=True)
            elif df.index.tz is None:
                df.index = df.index.tz_localize('UTC')

            # Identify market structure
            market_structure = self.identify_market_structure(df)
            logger.info(f"Market structure for {symbol}: {market_structure.get('trend', 'unknown')}")
            
            # Identify optimal trade entry (OTE) zones
            ote_zones = self.identify_ote_zones(df)
            logger.info(f"Found {len(ote_zones)} OTE zones for {symbol}")
            
            # Identify breaker blocks
            breaker_blocks = self.identify_breaker_blocks(df)
            logger.info(f"Found {len(breaker_blocks)} breaker blocks for {symbol}")
            
            # Identify fair value gaps
            fair_value_gaps = self.identify_fair_value_gaps(df)
            logger.info(f"Found {len(fair_value_gaps)} fair value gaps for {symbol}")
            
            # Identify kill zones
            kill_zones = self.identify_kill_zones(df)
            logger.info(f"Identified kill zones for {symbol}")
            
            # Determine overall market bias
            bias = market_structure.get('trend', 'neutral')
            
            # Return analysis results
            return {
                'symbol': symbol,
                'timeframe': timeframe,
                'bias': bias,
                'market_structure': market_structure,
                'ote_zones': ote_zones,
                'breaker_blocks': breaker_blocks,
                'fair_value_gaps': fair_value_gaps,
                'kill_zones': kill_zones,
                'signals': [] # ICT analysis primarily provides context, signals are generated by strategy
            }
            
        except Exception as e:
            logger.error(f"Error analyzing chart with ICT: {e}", exc_info=True)
            return {'error': str(e)}

    def identify_market_structure(self, df: pd.DataFrame) -> Dict:
        """
        Identify market structure (trend, swing highs/lows, HH, HL, LL, LH)
        
        Args:
            df (pd.DataFrame): OHLCV dataframe
            
        Returns:
            dict: Market structure details
        """
        # This is a simplified version, a more robust implementation would be in smc/market_structure.py
        # For now, we'll use a basic swing detection
        swing_highs = []
        swing_lows = []
        
        window = 5
        for i in range(window, len(df) - window):
            if all(df['high'].iloc[i] > df['high'].iloc[i-j] for j in range(1, window+1)) and \
               all(df['high'].iloc[i] > df['high'].iloc[i+j] for j in range(1, window+1)):
                swing_highs.append({
                    'index': i,
                    'price': df['high'].iloc[i],
                    'date': df.index[i]
                })
            
            if all(df['low'].iloc[i] < df['low'].iloc[i-j] for j in range(1, window+1)) and \
               all(df['low'].iloc[i] < df['low'].iloc[i+j] for j in range(1, window+1)):
                swing_lows.append({
                    'index': i,
                    'price': df['low'].iloc[i],
                    'date': df.index[i]
                })
        
        # Simple trend identification
        trend = 'neutral'
        if len(df) > 50:
            ma20 = df['close'].rolling(window=20).mean().iloc[-1]
            ma50 = df['close'].rolling(window=50).mean().iloc[-1]
            if ma20 > ma50:
                trend = 'bullish'
            elif ma20 < ma50:
                trend = 'bearish'

        return {
            'trend': trend,
            'swing_highs': swing_highs,
            'swing_lows': swing_lows
        }

    def identify_ote_zones(self, df: pd.DataFrame) -> List[Dict]:
        """
        Identify Optimal Trade Entry (OTE) zones using Fibonacci retracement.
        
        Args:
            df (pd.DataFrame): OHLCV dataframe
            
        Returns:
            list: OTE zones
        """
        ote_zones = []
        
        # Identify swing highs and lows (simplified for this module)
        market_structure = self.identify_market_structure(df)
        swing_highs = market_structure['swing_highs']
        swing_lows = market_structure['swing_lows']
        
        # Calculate 62% and 79% retracement levels for swings
        # For bullish moves (low to high)
        for i in range(1, len(swing_highs)):
            if i < len(swing_lows): # Ensure we have a preceding low
                low_point = swing_lows[i-1]
                high_point = swing_highs[i]
                
                if high_point['index'] > low_point['index']: # Ensure it's a valid swing up
                    range_size = high_point['price'] - low_point['price']
                    level_62 = high_point['price'] - range_size * 0.62
                    level_79 = high_point['price'] - range_size * 0.79
                    
                    ote_zones.append({
                        'type': 'bullish',
                        'top': level_62,
                        'bottom': level_79,
                        'swing_high_date': high_point['date'],
                        'swing_low_date': low_point['date'],
                        'strength': 70
                    })
        
        # For bearish moves (high to low)
        for i in range(1, len(swing_lows)):
            if i < len(swing_highs): # Ensure we have a preceding high
                high_point = swing_highs[i-1]
                low_point = swing_lows[i]
                
                if low_point['index'] > high_point['index']: # Ensure it's a valid swing down
                    range_size = high_point['price'] - low_point['price']
                    level_62 = low_point['price'] + range_size * 0.62
                    level_79 = low_point['price'] + range_size * 0.79
                    
                    ote_zones.append({
                        'type': 'bearish',
                        'top': level_79,
                        'bottom': level_62,
                        'swing_high_date': high_point['date'],
                        'swing_low_date': low_point['date'],
                        'strength': 70
                    })
        
        return ote_zones
    
    def identify_breaker_blocks(self, df: pd.DataFrame) -> List[Dict]:
        """
        Identify breaker blocks (ICT concept).
        A breaker block forms when price breaks a swing high/low, then fails to continue,
        and reverses to break the previous swing low/high, creating a new order block.
        
        Args:
            df (pd.DataFrame): OHLCV dataframe
            
        Returns:
            list: Breaker blocks
        """
        breaker_blocks = []
        
        # We need at least 20 candles for reliable breaker block identification
        if len(df) < 20:
            logger.warning("Not enough data to identify breaker blocks")
            return breaker_blocks
        
        # Look for bullish and bearish breaker blocks
        for i in range(3, len(df) - 5):
            # Bullish Breaker Block: 
            # A bearish candle that is later broken by price, then price continues higher
            if (df['close'].iloc[i] < df['open'].iloc[i] and  # Bearish candle
                df['high'].iloc[i+1:i+6].max() > df['high'].iloc[i] and  # Price breaks above
                df['close'].iloc[i+5] > df['high'].iloc[i]):  # Price continues higher
                
                strength = 60  # Base strength for breaker blocks
                
                breaker_blocks.append({
                    'type': 'bullish',
                    'index': i,
                    'date': df.index[i],
                    'top': df['high'].iloc[i],
                    'bottom': df['low'].iloc[i],
                    'strength': strength,
                    'age': len(df) - i - 1  # How many candles ago
                })
            
            # Bearish Breaker Block: 
            # A bullish candle that is later broken by price, then price continues lower
            if (df['close'].iloc[i] > df['open'].iloc[i] and  # Bullish candle
                df['low'].iloc[i+1:i+6].min() < df['low'].iloc[i] and  # Price breaks below
                df['close'].iloc[i+5] < df['low'].iloc[i]):  # Price continues lower
                
                strength = 60  # Base strength for breaker blocks
                
                breaker_blocks.append({
                    'type': 'bearish',
                    'index': i,
                    'date': df.index[i],
                    'top': df['high'].iloc[i],
                    'bottom': df['low'].iloc[i],
                    'strength': strength,
                    'age': len(df) - i - 1  # How many candles ago
                })
        
        # Sort by age (ascending)
        breaker_blocks.sort(key=lambda x: x['age'])
        
        return breaker_blocks
    
    def identify_fair_value_gaps(self, df: pd.DataFrame) -> List[Dict]:
        """
        Identify fair value gaps (FVG).
        
        Args:
            df (pd.DataFrame): OHLCV dataframe
            
        Returns:
            list: Fair value gaps with type, price range, and status
        """
        fair_value_gaps = []
        
        if len(df) < 3:
            logger.warning("Not enough data to identify fair value gaps")
            return fair_value_gaps
        
        for i in range(1, len(df) - 1):
            # Bullish FVG: Low of current candle > High of previous candle
            if df['low'].iloc[i+1] > df['high'].iloc[i-1]:
                gap_size = df['low'].iloc[i+1] - df['high'].iloc[i-1]
                if gap_size > 0: # Only consider positive gaps
                    filled = False
                    for j in range(i+2, len(df)):
                        if df['low'].iloc[j] <= df['high'].iloc[i-1]:
                            filled = True
                            break
                    
                    fair_value_gaps.append({
                        'type': 'bullish',
                        'index': i,
                        'date': df.index[i],
                        'top': df['low'].iloc[i+1],
                        'bottom': df['high'].iloc[i-1],
                        'size': gap_size,
                        'filled': filled,
                        'age': len(df) - i - 1
                    })
            
            # Bearish FVG: High of current candle < Low of previous candle
            if df['high'].iloc[i+1] < df['low'].iloc[i-1]:
                gap_size = df['low'].iloc[i-1] - df['high'].iloc[i+1]
                if gap_size > 0: # Only consider positive gaps
                    filled = False
                    for j in range(i+2, len(df)):
                        if df['high'].iloc[j] >= df['low'].iloc[i-1]:
                            filled = True
                            break
                    
                    fair_value_gaps.append({
                        'type': 'bearish',
                        'index': i,
                        'date': df.index[i],
                        'top': df['low'].iloc[i-1],
                        'bottom': df['high'].iloc[i+1],
                        'size': gap_size,
                        'filled': filled,
                        'age': len(df) - i - 1
                    })
        
        fair_value_gaps.sort(key=lambda x: (x['age'], -x['size']))
        return [gap for gap in fair_value_gaps if not gap['filled']][:10] # Return top 10 unfilled
    
    def identify_kill_zones(self, df: pd.DataFrame) -> Dict:
        """
        Identify kill zones (London and New York sessions) based on UTC+1.
        
        Args:
            df (pd.DataFrame): OHLCV dataframe
            
        Returns:
            dict: Kill zones analysis, including current kill zone status
        """
        # Ensure index is datetime and localized to UTC
        if not isinstance(df.index, pd.DatetimeIndex):
            df.index = pd.to_datetime(df.index, utc=True)
        elif df.index.tz is None:
            df.index = df.index.tz_localize('UTC')

        # Convert to the target timezone (Europe/Bratislava, UTC+1) for session logic
        target_timezone = pytz.timezone('Europe/Bratislava')
        df_localized = df.tz_convert(target_timezone)
        
        london_session_data = []
        new_york_session_data = []
        
        # London session: 8:00-11:00 UTC+1
        # New York session: 14:00-17:00 UTC+1
        
        for i in range(len(df_localized)):
            hour = df_localized.index[i].hour
            
            if 8 <= hour < 11:
                london_session_data.append(df_localized.iloc[i])
            
            if 14 <= hour < 17:
                new_york_session_data.append(df_localized.iloc[i])
        
        london_analysis = self._analyze_session_price_action(pd.DataFrame(london_session_data))
        new_york_analysis = self._analyze_session_price_action(pd.DataFrame(new_york_session_data))

        # Determine current kill zone status
        current_time = df_localized.index[-1].time() if not df_localized.empty else None
        is_in_current_kill_zone = False
        current_kill_zone_name = None

        if current_time:
            # London morning session: 7:00-9:00 UTC (as per UnifiedStrategy's _is_in_kill_zone)
            if time(7, 0) <= current_time < time(9, 0):
                is_in_current_kill_zone = True
                current_kill_zone_name = 'london_morning'
            # London/NY overlap: 12:00-15:00 UTC
            elif time(12, 0) <= current_time < time(15, 0):
                is_in_current_kill_zone = True
                current_kill_zone_name = 'london_ny_overlap'
            # NY afternoon: 17:00-19:00 UTC
            elif time(17, 0) <= current_time < time(19, 0):
                is_in_current_kill_zone = True
                current_kill_zone_name = 'ny_afternoon'
            # Asian session: 22:00-1:00 UTC
            elif current_time >= time(22, 0) or current_time < time(1, 0):
                is_in_current_kill_zone = True
                current_kill_zone_name = 'asian_session'
        
        return {
            'london': london_analysis,
            'new_york': new_york_analysis,
            'current_kill_zone': (is_in_current_kill_zone, current_kill_zone_name)
        }
    
    def _analyze_session_price_action(self, session_df: pd.DataFrame) -> Dict:
        """
        Analyze price action during a trading session.
        
        Args:
            session_df (pd.DataFrame): OHLCV data for the session
            
        Returns:
            dict: Session price action analysis
        """
        if session_df.empty:
            return {'bias': 'neutral', 'strength': 0, 'avg_range': 0, 'bullish_candles': 0, 'bearish_candles': 0}
        
        bullish_candles = 0
        bearish_candles = 0
        
        for _, row in session_df.iterrows():
            if row['close'] > row['open']:
                bullish_candles += 1
            elif row['close'] < row['open']:
                bearish_candles += 1
        
        session_ranges = (session_df['high'] - session_df['low']) / session_df['low'] * 100
        avg_range = session_ranges.mean() if not session_ranges.empty else 0
        
        bias = 'neutral'
        strength = 50
        if bullish_candles > bearish_candles * 1.5:
            bias = 'bullish'
            strength = min(100, int((bullish_candles / (bullish_candles + bearish_candles)) * 100))
        elif bearish_candles > bullish_candles * 1.5:
            bias = 'bearish'
            strength = min(100, int((bearish_candles / (bullish_candles + bearish_candles)) * 100))
        
        return {
            'bias': bias,
            'strength': strength,
            'avg_range': avg_range,
            'bullish_candles': bullish_candles,
            'bearish_candles': bearish_candles
        }
